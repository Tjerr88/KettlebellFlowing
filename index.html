<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kettlebell Flowing v4 — Dual-State Seamless Engine</title>
  <style>
    :root{
      --bg:#0b0f14;
      --card:#121a26;
      --border:rgba(255,255,255,.10);
      --muted:#9fb0c3;
      --text:#e6eef8;
      --btn:#1e293b;
      --btn2:#0f172a;
      --good:#22c55e;
      --warn:#f59e0b;
      --bad:#ef4444;
    }
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto;background:var(--bg);color:var(--text);padding:16px}
    .wrap{max-width:920px;margin:0 auto}
    h1{font-size:20px;margin:0 0 12px 0}
    .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:14px;margin-bottom:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    button{appearance:none;border:1px solid rgba(255,255,255,.20);background:var(--btn);color:var(--text);padding:10px 12px;border-radius:12px;cursor:pointer}
    button:hover{background:#334155}
    button.secondary{background:var(--btn2)}
    button.ghost{background:transparent}
    select{padding:10px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.20);background:var(--btn2);color:var(--text)}
    .muted{color:var(--muted);font-size:13px}
    .flowStep{padding:10px 0;border-bottom:1px solid rgba(255,255,255,.08)}
    details{border:1px solid rgba(255,255,255,.10);border-radius:14px;padding:8px 10px;background:rgba(255,255,255,.02);margin-top:10px}
    summary{cursor:pointer;list-style:none;font-weight:700}
    summary::-webkit-details-marker{display:none}
    .sub{margin-top:10px}
    .pill{display:inline-flex;align-items:center;gap:8px;border:1px solid rgba(255,255,255,.18);border-radius:999px;padding:6px 10px;font-size:13px;color:var(--muted)}
    .timer{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:34px;margin-top:10px}
    .spacer{height:6px}
    .k{font-weight:700;color:var(--text)}
    .grid2{display:grid;grid-template-columns:1fr;gap:10px}
    @media(min-width:860px){ .grid2{grid-template-columns:1.25fr .75fr} }
    .tag{display:inline-flex;align-items:center;border:1px solid rgba(255,255,255,.16);border-radius:999px;padding:2px 8px;font-size:12px;color:var(--muted)}
    .tag.good{border-color:rgba(34,197,94,.35);color:#86efac}
    .tag.warn{border-color:rgba(245,158,11,.35);color:#fcd34d}
    .tag.bad{border-color:rgba(239,68,68,.35);color:#fca5a5}
    .mini{font-size:12px;color:var(--muted)}
    .meta{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
    .tiny{font-size:12px;color:var(--muted)}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,monospace}
  </style>
</head>
<body>
<div class="wrap">
  <h1>Kettlebell Flowing v4 — Dual-State Seamless Engine</h1>

  <div class="card">
    <div class="row">
      <button onclick="generateFlow()">Nieuwe flow</button>
      <select id="vocabMode" title="Core = strak en betrouwbaar. Full = rijker (meer routes).">
        <option value="core">Vocab: Core</option>
        <option value="full">Vocab: Full</option>
      </select>
      <select id="intentMode" title="Intent stuurt voorkeuren (laag, rotatie, travel, etc.)">
        <option value="auto">Intent: Auto</option>
        <option value="play">Intent: Play</option>
        <option value="travel">Intent: Travel</option>
        <option value="rotation">Intent: Rotation</option>
        <option value="low">Intent: Low</option>
        <option value="mixed">Intent: Mixed</option>
      </select>
      <span class="pill">Start: <span class="k" id="baseLabel">—</span></span>
      <span class="pill">Intent: <span class="k" id="intentLabel">—</span></span>
    </div>

    <div class="grid2" style="margin-top:12px">
      <div>
        <div class="sub" id="flowList"></div>
      </div>
      <div>
        <div class="card" style="margin:0;background:rgba(255,255,255,.02)">
          <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:10px">
            <div>
              <div class="k">Seamless regels</div>
              <div class="muted" style="margin-top:4px">
                Elke stap moet aansluiten op <span class="k">body state</span> én <span class="k">bell state</span>.
                “Transities” zijn echte moves.
              </div>
            </div>
            <span class="tag good" id="cohTag">coherent</span>
          </div>
          <div class="mini" style="margin-top:10px" id="statsLine">—</div>
        </div>
      </div>
    </div>

    <details open>
      <summary>Segment 1 — Woorden leren</summary>
      <div class="muted spacer">3–5 reps per stap (explosief: 2–4). Dit is techniek / vocab.</div>
      <div id="seg1"></div>
    </details>

    <details open>
      <summary>Segment 2 — Zin oefenen</summary>
      <div class="muted spacer">Oefen de volledige flow 1–3x. Neem aan het einde rust om na te denken en te finetunen.</div>
      <div class="row" style="margin-top:8px">
        <select id="seg2Rounds">
          <option value="1">1x flow</option>
          <option value="2" selected>2x flow</option>
          <option value="3">3x flow</option>
        </select>
        <select id="seg2Rest">
          <option value="30">Rust 0:30</option>
          <option value="60" selected>Rust 1:00</option>
          <option value="90">Rust 1:30</option>
        </select>
        <button class="secondary" onclick="startSeg2Rest()">Start rust</button>
        <button class="ghost" onclick="stopSeg2Rest()">Stop</button>
      </div>
      <div class="timer" id="seg2Timer">01:00</div>
      <div id="seg2"></div>
    </details>

    <details open>
      <summary>Segment 3 — Vloeiend spreken</summary>
      <div class="muted spacer">Continuous • 10 min max quality (of 15 min). Geen nadenk-pauzes, alleen flow.</div>
      <div class="row" style="margin-top:10px">
        <select id="seg3Minutes">
          <option value="10" selected>10:00</option>
          <option value="15">15:00</option>
        </select>
        <button onclick="startTimer()">Start</button>
        <button class="secondary" onclick="stopTimer()">Stop</button>
        <span class="pill">Wake Lock: <span class="k" id="wlLabel">off</span></span>
      </div>
      <div class="timer" id="timerDisplay">10:00</div>
    </details>
  </div>

  <div class="card muted">
    <div class="k" style="margin-bottom:6px">v4 note</div>
    <div>• v3 checkte vooral <span class="k">lichaam</span>. v4 checkt <span class="k">lichaam + bell</span>. Dus: geen “rotational clean → reverse get up” zonder eerst <span class="k">rack → overhead</span>.</div>
    <div>• Body-only moves laten de bell state gelijk ("* → *"). Dat kan alleen als de positie realistisch is (bijv. half kneel met rack of OH is oké).</div>
  </div>
</div>

<script>
/* --------------------- Persistence --------------------- */
const LS_KEY = "KB_FLOWING_V4_DUALSTATE_STATE";

/* --------------------- Audio (beep) --------------------- */
let audioCtx = null;
function beep(freq=880, ms=120){
  try{
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = "sine";
    o.frequency.value = freq;
    g.gain.value = 0.05;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    setTimeout(()=>{ o.stop(); }, ms);
  }catch(e){}
}

/* --------------------- Wake Lock --------------------- */
let wakeLock = null;
async function enableWakeLock(){
  try{
    if("wakeLock" in navigator){
      wakeLock = await navigator.wakeLock.request("screen");
      document.getElementById("wlLabel").textContent = "on";
      wakeLock.addEventListener("release", ()=>{ document.getElementById("wlLabel").textContent = "off"; });
    }
  }catch(e){ document.getElementById("wlLabel").textContent = "off"; }
}
async function disableWakeLock(){
  try{ if(wakeLock){ await wakeLock.release(); wakeLock=null; } }catch(e){}
  document.getElementById("wlLabel").textContent = "off";
}

let timerInterval = null;
let timerRunning = false;
let endAt = 0;
function formatMMSS(totalSeconds){
  const min = Math.floor(totalSeconds/60);
  const sec = totalSeconds%60;
  return `${String(min).padStart(2,"0")}:${String(sec).padStart(2,"0")}`;
}

document.addEventListener("visibilitychange", ()=>{
  if(document.visibilityState === "visible" && timerRunning){ enableWakeLock(); }
});

/* --------------------- Dual States --------------------- */
const BODY = {
  SUPINE: "floor/supine",
  SEATED: "floor/seated",
  PLANK:  "floor/plank",
  HALF:   "half kneel",
  TALL:   "tall kneel",
  HINGE:  "hinge",
  STAND:  "stand"
};

const BELL = {
  GROUND: "ground",      // not held / parked / handles
  HANG:   "hang",        // held at hinge (between legs / dead hang)
  RACK:   "rack",
  OH:     "overhead"
};

const INTENTS = ["Play","Travel","Rotation","Low","Mixed"];

function M(name, bodyFrom, bodyTo, bellFrom, bellTo, tags={}){
  // bellTo can be '*' meaning unchanged
  // tags: plane, level, ballistic, tech, transfer, rotation
  return {name, bodyFrom, bodyTo, bellFrom, bellTo, ...tags};
}

/* --------------------- Bases (body + bell) --------------------- */
const BASES = [
  {name:"Floor (Supine) • bell on ground", body:BODY.SUPINE, bell:BELL.GROUND, w:10},
  {name:"Floor (Plank) • bell on ground", body:BODY.PLANK, bell:BELL.GROUND, w:16},
  {name:"Floor (Seated) • bell on ground", body:BODY.SEATED, bell:BELL.GROUND, w:10},
  {name:"Half Kneel • bell on ground", body:BODY.HALF, bell:BELL.GROUND, w:10},
  {name:"Tall Kneel • bell on ground", body:BODY.TALL, bell:BELL.GROUND, w:8},
  {name:"Hinge • bell in hang", body:BODY.HINGE, bell:BELL.HANG, w:18},
  {name:"Stand • bell on ground", body:BODY.STAND, bell:BELL.GROUND, w:14},
  {name:"Stand • bell in rack", body:BODY.STAND, bell:BELL.RACK, w:14},
  {name:"Stand • bell overhead", body:BODY.STAND, bell:BELL.OH, w:10}
];

/* --------------------- Vocabulary --------------------- */
const CORE = [
  // Ground / plank with bell parked (handles)
  M("Push-Up on KBs", [BODY.PLANK], BODY.PLANK, [BELL.GROUND], BELL.GROUND, {plane:"sag", level:"ground", ballistic:false, tech:false, transfer:false, rotation:false}),
  M("Plank Drag (KB pull-through)", [BODY.PLANK], BODY.PLANK, [BELL.GROUND], BELL.GROUND, {plane:"trans", level:"ground", ballistic:false, tech:true, transfer:false, rotation:true}),
  // Body-only plank actions (bell can be any; bell state unchanged)
  M("Kick Through", [BODY.PLANK], BODY.PLANK, ["*"], "*", {plane:"trans", level:"ground", ballistic:false, tech:false, transfer:false, rotation:true}),
  M("Beast / High Plank Hold (breath)", [BODY.PLANK], BODY.PLANK, ["*"], "*", {plane:"multi", level:"ground", ballistic:false, tech:false, transfer:false, rotation:false}),

  // Ground transitions (body-only; bell unchanged)
  M("Jump Through to Seated", [BODY.PLANK], BODY.SEATED, ["*"], "*", {plane:"sag", level:"ground", ballistic:true, tech:true, transfer:true, rotation:false}),
  M("Jump Through to Hinge", [BODY.PLANK], BODY.HINGE, ["*"], "*", {plane:"sag", level:"low", ballistic:true, tech:true, transfer:true, rotation:false}),
  M("Step Up to Half Kneel", [BODY.PLANK], BODY.HALF, ["*"], "*", {plane:"sag", level:"low", ballistic:false, tech:true, transfer:true, rotation:false}),

  // Seated / supine (mostly with bell parked)
  M("Russian Twist", [BODY.SEATED], BODY.SEATED, [BELL.GROUND, BELL.RACK], "*", {plane:"trans", level:"ground", ballistic:false, tech:false, transfer:false, rotation:true}),
  M("Seated KB Switch (around the world)", [BODY.SEATED], BODY.SEATED, [BELL.GROUND, BELL.RACK], "*", {plane:"trans", level:"ground", ballistic:false, tech:false, transfer:false, rotation:true}),
  M("Sit-Through to Plank", [BODY.SEATED], BODY.PLANK, ["*"], "*", {plane:"sag", level:"ground", ballistic:false, tech:true, transfer:true, rotation:false}),
  M("Supine Bridge", [BODY.SUPINE], BODY.SUPINE, ["*"], "*", {plane:"sag", level:"ground", ballistic:false, tech:false, transfer:false, rotation:false}),
  M("Supine KB Press", [BODY.SUPINE], BODY.SUPINE, [BELL.RACK], BELL.RACK, {plane:"sag", level:"ground", ballistic:false, tech:false, transfer:false, rotation:false}),
  M("Supine Roll to Seated", [BODY.SUPINE], BODY.SEATED, ["*"], "*", {plane:"multi", level:"ground", ballistic:false, tech:true, transfer:true, rotation:true}),

  // Kneeling (bell unchanged unless specified)
  M("Tall Kneel Hinge", [BODY.TALL], BODY.TALL, ["*"], "*", {plane:"sag", level:"low", ballistic:false, tech:false, transfer:false, rotation:false}),
  M("Half Kneel to Tall Kneel", [BODY.HALF], BODY.TALL, ["*"], "*", {plane:"sag", level:"low", ballistic:false, tech:false, transfer:true, rotation:false}),
  M("Tall Kneel to Half Kneel", [BODY.TALL], BODY.HALF, ["*"], "*", {plane:"sag", level:"low", ballistic:false, tech:false, transfer:true, rotation:false}),
  M("Kneel to Stand", [BODY.HALF, BODY.TALL], BODY.STAND, ["*"], "*", {plane:"sag", level:"mid", ballistic:false, tech:true, transfer:true, rotation:false}),
  M("Stand to Half Kneel", [BODY.STAND], BODY.HALF, ["*"], "*", {plane:"sag", level:"low", ballistic:false, tech:true, transfer:true, rotation:false}),

  // Hinge / stand with bell mechanics
  M("Pick Up to Hang", [BODY.HINGE, BODY.STAND], BODY.HINGE, [BELL.GROUND], BELL.HANG, {plane:"sag", level:"low", ballistic:false, tech:true, transfer:true, rotation:false}),
  M("Park Bell to Ground", [BODY.HINGE], BODY.HINGE, [BELL.HANG], BELL.GROUND, {plane:"sag", level:"low", ballistic:false, tech:true, transfer:true, rotation:false}),

  M("Deadlift", [BODY.HINGE, BODY.STAND], BODY.HINGE, [BELL.HANG], BELL.HANG, {plane:"sag", level:"low", ballistic:false, tech:false, transfer:false, rotation:false}),
  M("Bent-Over Row", [BODY.HINGE], BODY.HINGE, [BELL.HANG], BELL.HANG, {plane:"sag", level:"low", ballistic:false, tech:false, transfer:false, rotation:false}),

  M("Clean", [BODY.HINGE, BODY.STAND], BODY.STAND, [BELL.HANG], BELL.RACK, {plane:"sag", level:"mid", ballistic:true, tech:false, transfer:false, rotation:false}),
  M("Front Squat", [BODY.STAND], BODY.STAND, [BELL.RACK], BELL.RACK, {plane:"sag", level:"mid", ballistic:false, tech:false, transfer:false, rotation:false}),
  M("Halo", [BODY.STAND], BODY.STAND, [BELL.RACK], BELL.RACK, {plane:"trans", level:"mid", ballistic:false, tech:false, transfer:false, rotation:true}),

  // Rack / overhead mechanics
  M("Military Press", [BODY.STAND, BODY.HALF, BODY.TALL], "*", [BELL.RACK], BELL.OH, {plane:"sag", level:"high", ballistic:false, tech:false, transfer:false, rotation:false}),
  M("Push Press", [BODY.STAND], BODY.STAND, [BELL.RACK], BELL.OH, {plane:"sag", level:"high", ballistic:true, tech:false, transfer:false, rotation:false}),
  M("Overhead to Rack (controlled)", [BODY.STAND, BODY.HALF, BODY.TALL], "*", [BELL.OH], BELL.RACK, {plane:"sag", level:"mid", ballistic:false, tech:true, transfer:false, rotation:false}),

  // Overhead rotations
  M("Windmill", [BODY.STAND], BODY.STAND, [BELL.OH], BELL.OH, {plane:"front", level:"high", ballistic:false, tech:true, transfer:false, rotation:true}),
  M("Half Kneel Windmill", [BODY.HALF], BODY.HALF, [BELL.OH], BELL.OH, {plane:"front", level:"high", ballistic:false, tech:true, transfer:false, rotation:true}),

  // Ballistics
  M("Snatch", [BODY.HINGE, BODY.STAND], BODY.STAND, [BELL.HANG], BELL.OH, {plane:"sag", level:"high", ballistic:true, tech:true, transfer:false, rotation:false}),

  // Get-up system (mechanically correct)
  M("Get Up to Stand", [BODY.SUPINE], BODY.STAND, [BELL.GROUND], BELL.OH, {plane:"multi", level:"mid", ballistic:false, tech:true, transfer:true, rotation:true}),
  M("Reverse Get Up to Half Kneel", [BODY.STAND, BODY.HALF], BODY.HALF, [BELL.OH], BELL.OH, {plane:"multi", level:"low", ballistic:false, tech:true, transfer:true, rotation:true}),
  M("Reverse Get Up to Supine", [BODY.STAND, BODY.HALF], BODY.SUPINE, [BELL.OH], BELL.GROUND, {plane:"multi", level:"ground", ballistic:false, tech:true, transfer:true, rotation:true})
];

const FULL_EXTRA = [
  M("One-Arm Swing", [BODY.HINGE, BODY.STAND], BODY.HINGE, [BELL.HANG], BELL.HANG, {plane:"sag", level:"low", ballistic:true, tech:false, transfer:false, rotation:false}),
  M("Hand-to-Hand Swing", [BODY.HINGE, BODY.STAND], BODY.HINGE, [BELL.HANG], BELL.HANG, {plane:"sag", level:"low", ballistic:true, tech:false, transfer:false, rotation:false}),
  M("Figure 8", [BODY.HINGE, BODY.STAND], BODY.HINGE, [BELL.HANG], BELL.HANG, {plane:"trans", level:"low", ballistic:true, tech:true, transfer:false, rotation:true}),
  M("Rotational Clean", [BODY.HINGE, BODY.STAND], BODY.STAND, [BELL.HANG], BELL.RACK, {plane:"trans", level:"mid", ballistic:true, tech:true, transfer:false, rotation:true}),
  M("Tactical Clean", [BODY.HINGE, BODY.STAND], BODY.STAND, [BELL.HANG], BELL.RACK, {plane:"multi", level:"mid", ballistic:true, tech:true, transfer:false, rotation:true}),
  M("Tactical Snatch", [BODY.HINGE, BODY.STAND], BODY.STAND, [BELL.HANG], BELL.OH, {plane:"multi", level:"high", ballistic:true, tech:true, transfer:false, rotation:true}),
  M("Half Kneel Press", [BODY.HALF], BODY.HALF, [BELL.RACK], BELL.OH, {plane:"sag", level:"high", ballistic:false, tech:true, transfer:false, rotation:false}),
  M("Tall Kneel Press", [BODY.TALL], BODY.TALL, [BELL.RACK], BELL.OH, {plane:"sag", level:"high", ballistic:false, tech:true, transfer:false, rotation:false}),
  M("Half Kneel to Stand + Clean", [BODY.HALF], BODY.STAND, [BELL.HANG], BELL.RACK, {plane:"multi", level:"mid", ballistic:true, tech:true, transfer:true, rotation:false}),
  M("Rack Reverse Lunge", [BODY.STAND], BODY.STAND, [BELL.RACK], BELL.RACK, {plane:"sag", level:"mid", ballistic:false, tech:true, transfer:false, rotation:false}),
  M("Overhead Reverse Lunge", [BODY.STAND], BODY.STAND, [BELL.OH], BELL.OH, {plane:"sag", level:"high", ballistic:false, tech:true, transfer:false, rotation:false}),
  M("Cossack Squat", [BODY.STAND], BODY.STAND, ["*"], "*", {plane:"front", level:"mid", ballistic:false, tech:true, transfer:false, rotation:true}),
  M("Lateral Step to Hinge", [BODY.STAND], BODY.HINGE, ["*"], "*", {plane:"front", level:"low", ballistic:false, tech:false, transfer:true, rotation:false})
];

function getVocab(){
  const mode = document.getElementById("vocabMode").value;
  return mode === "full" ? CORE.concat(FULL_EXTRA) : CORE.slice();
}

/* --------------------- Helpers --------------------- */
function weightedChoice(arr){
  let total = arr.reduce((s,x)=>s+x.w,0);
  let r = Math.random()*total;
  for(const x of arr){ r -= x.w; if(r<=0) return x; }
  return arr[0];
}
function rChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function randint(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }

function bellLabel(b){
  if(b===BELL.GROUND) return "ground";
  if(b===BELL.HANG) return "hang";
  if(b===BELL.RACK) return "rack";
  if(b===BELL.OH) return "OH";
  return String(b);
}

function bodyLabel(s){ return s; }

/* --------------------- Generator --------------------- */
function generateFlow(){
  const vocab = getVocab();

  // intent
  const intentSel = document.getElementById("intentMode").value;
  const intent = intentSel === "auto" ? rChoice(INTENTS) : (
    intentSel === "play" ? "Play" :
    intentSel === "travel" ? "Travel" :
    intentSel === "rotation" ? "Rotation" :
    intentSel === "low" ? "Low" : "Mixed"
  );

  // base weights with intent bias
  let bases = BASES.map(x=>({...x}));
  if(intent === "Low"){
    bases = bases.map(b=> ({...b, w: (b.body.startsWith("floor/") ? b.w+10 : Math.max(1,b.w-2)) }));
  }
  if(intent === "Travel"){
    bases = bases.map(b=> ({...b, w: ([BODY.PLANK,BODY.SEATED,BODY.SUPINE,BODY.HALF,BODY.TALL].includes(b.body) ? b.w+5 : b.w) }));
  }
  if(intent === "Rotation"){
    bases = bases.map(b=> ({...b, w: ((b.bell===BELL.RACK||b.bell===BELL.OH||b.body===BODY.PLANK) ? b.w+4 : b.w) }));
  }

  const baseObj = weightedChoice(bases);
  let body = baseObj.body;
  let bell = baseObj.bell;

  const used = new Set();
  let last = null;

  let tech=0, ballistic=0, transfer=0, rotation=0;
  let consecutiveBallistic=0;
  let lastPlane=null;
  let lastEndBody=null;
  let lastEndBell=null;

  const targetLen = randint(7,10);
  const flow = [];

  function bellFromOk(m){
    if(m.bellFrom.includes("*")) return true;
    return m.bellFrom.includes(bell);
  }
  function bodyFromOk(m){
    return m.bodyFrom.includes(body);
  }

  function eligible(m){
    if(!bodyFromOk(m)) return false;
    if(!bellFromOk(m)) return false;
    if(used.has(m.name)) return false;
    if(m.name === last) return false;

    // soft caps
    if(m.tech && tech>=5) return false;
    if(m.ballistic && ballistic>=4) return false;
    if(m.transfer && transfer>=4) return false;

    // avoid ballistic streaks
    if(m.ballistic && consecutiveBallistic>=2) return false;

    // Safety: avoid going to plank with bell NOT ground unless explicitly body-only & realistic.
    // (We allow plank with rack/OH via body-only moves, but keep it rarer)
    if(m.bodyTo === BODY.PLANK){
      const nextBell = (m.bellTo === "*") ? bell : m.bellTo;
      if(nextBell !== BELL.GROUND){
        // only allow if it's explicitly a body-only move and tech
        if(!(m.bellFrom.includes("*") && m.bellTo === "*" && m.tech)) return false;
      }
    }

    // Intent guardrails
    if(intent !== "Low"){
      if(!body.startsWith("floor/") && m.bodyTo.startsWith("floor/")){
        const ok = m.name.includes("Get Up") || m.name.includes("Sit-Through") || m.name.includes("Jump Through") || m.name.includes("Roll");
        if(!ok) return false;
      }
    }

    return true;
  }

  function score(m){
    let s = 1;

    // intent nudges
    if(intent === "Rotation" && (m.rotation || m.plane === "trans")) s += 3;
    if(intent === "Travel" && m.transfer) s += 3;
    if(intent === "Low" && (m.level === "ground" || m.bodyTo.startsWith("floor/"))) s += 3;

    // prefer variety: change plane
    if(lastPlane && m.plane === lastPlane) s -= 1;
    if(lastPlane && m.plane !== lastPlane) s += 1;

    // prefer variety in end states (body + bell)
    const nextEndBody = (m.bodyTo === "*") ? body : m.bodyTo;
    const nextEndBell = (m.bellTo === "*") ? bell : m.bellTo;

    if(lastEndBody && nextEndBody === lastEndBody) s -= 1;
    if(lastEndBody && nextEndBody !== lastEndBody) s += 1;
    if(lastEndBell && nextEndBell === lastEndBell) s -= 1;
    if(lastEndBell && nextEndBell !== lastEndBell) s += 1;

    // small preference: if bell is on ground, encourage pick up soon unless Low/ground intent
    if(bell === BELL.GROUND && m.name === "Pick Up to Hang") s += 2;

    // small preference: avoid "park" too early
    if(flow.length < 4 && m.name === "Park Bell to Ground") s -= 2;

    return Math.max(1, s);
  }

  function pickMove(){
    const pool = vocab.filter(eligible);
    if(!pool.length) return null;

    const scored = pool.map(m=>({m, w: score(m)}));
    let total = scored.reduce((a,x)=>a+x.w,0);
    let r = Math.random()*total;
    for(const x of scored){ r -= x.w; if(r<=0) return x.m; }
    return scored[0].m;
  }

  let guard=0;
  while(flow.length < targetLen && guard < 160){
    guard++;
    const m = pickMove();
    if(!m) break;

    // push
    flow.push(m);
    used.add(m.name);
    last = m.name;

    // update stats
    if(m.tech) tech++;
    if(m.ballistic) ballistic++;
    if(m.transfer) transfer++;
    if(m.rotation) rotation++;

    // ballistic streak
    if(m.ballistic) consecutiveBallistic++; else consecutiveBallistic=0;
    lastPlane = m.plane || null;

    // update states
    body = (m.bodyTo === "*") ? body : m.bodyTo;
    bell = (m.bellTo === "*") ? bell : m.bellTo;
    lastEndBody = body;
    lastEndBell = bell;

    // stop early if it already feels like a complete sentence
    if(flow.length>=7 && transfer>=2 && rotation>=1){
      if(Math.random() < 0.35) break;
    }
  }

  // coherence check
  const coherent = checkCoherence(baseObj, flow);
  document.getElementById("cohTag").textContent = coherent.ok ? "coherent" : "warning";
  document.getElementById("cohTag").className = "tag " + (coherent.ok ? "good" : "warn");

  // store
  const payload = {vocabMode:document.getElementById("vocabMode").value, intentMode:document.getElementById("intentMode").value, base:baseObj, intent, flow};
  try{ localStorage.setItem(LS_KEY, JSON.stringify(payload)); }catch(e){}

  renderAll(baseObj, intent, flow, coherent);
}

function checkCoherence(baseObj, flow){
  let b = baseObj.body;
  let k = baseObj.bell;
  const problems=[];

  for(let i=0;i<flow.length;i++){
    const m = flow[i];
    const bodyOk = m.bodyFrom.includes(b);
    const bellOk = m.bellFrom.includes("*") || m.bellFrom.includes(k);
    if(!bodyOk || !bellOk){
      problems.push({i, name:m.name, expectedBody:b, expectedBell:k});
      // try to continue with "best guess" to avoid cascading
    }
    b = (m.bodyTo === "*") ? b : m.bodyTo;
    k = (m.bellTo === "*") ? k : m.bellTo;
  }

  return {ok: problems.length===0, problems};
}

function renderAll(baseObj, intent, flow, coherent){
  document.getElementById("baseLabel").textContent = baseObj.name;
  document.getElementById("intentLabel").textContent = intent;

  // list
  const list = document.getElementById("flowList");
  list.innerHTML = "";

  const stats = {
    moves: flow.length,
    ballistic: flow.filter(x=>x.ballistic).length,
    tech: flow.filter(x=>x.tech).length,
    travel: flow.filter(x=>x.transfer).length,
    rotation: flow.filter(x=>x.rotation).length
  };

  document.getElementById("statsLine").textContent = `Moves: ${stats.moves} • ballistic: ${stats.ballistic} • tech: ${stats.tech} • travel: ${stats.travel} • rotation: ${stats.rotation}`;

  // show each step with both state tracks
  // reconstruct the chain so we can print the actual transitions
  let b = baseObj.body;
  let k = baseObj.bell;

  flow.forEach((m,i)=>{
    const bTo = (m.bodyTo === "*") ? b : m.bodyTo;
    const kTo = (m.bellTo === "*") ? k : m.bellTo;

    const tags=[];
    if(m.tech) tags.push('<span class="tag warn">tech</span>');
    if(m.ballistic) tags.push('<span class="tag">ballistic</span>');
    if(m.transfer) tags.push('<span class="tag">travel</span>');
    if(m.rotation) tags.push('<span class="tag">rot</span>');

    list.innerHTML += `
      <div class="flowStep">
        <div style="display:flex;justify-content:space-between;gap:10px;align-items:flex-start">
          <div>
            <div class="k">${i+1}. ${m.name}</div>
            <div class="tiny mono">body: ${bodyLabel(b)} → <span class="k">${bodyLabel(bTo)}</span> &nbsp;|&nbsp; bell: ${bellLabel(k)} → <span class="k">${bellLabel(kTo)}</span> &nbsp;• plane: ${m.plane||"—"}</div>
          </div>
          <div class="meta">${tags.join('')}</div>
        </div>
      </div>
    `;

    b = bTo; k = kTo;
  });

  // Segment 1 reps
  const seg1 = document.getElementById("seg1");
  seg1.innerHTML = "";
  flow.forEach((m,i)=>{
    const reps = m.ballistic ? randint(2,4) : randint(3,5);
    seg1.innerHTML += `<div class="flowStep">${i+1}. ${m.name} — <span class="k">${reps}</span> reps</div>`;
  });

  // Segment 2 instructions
  const seg2 = document.getElementById("seg2");
  const rounds = parseInt(document.getElementById("seg2Rounds").value,10);
  seg2.innerHTML = `<div class="flowStep">Doe de volledige flow <span class="k">${rounds}</span>x. Daarna: rust en evalueer (tempo, handwissel, adem, bel-pad).</div>`;

  // Seg2 timer display sync
  const rest = parseInt(document.getElementById("seg2Rest").value,10);
  document.getElementById("seg2Timer").textContent = formatMMSS(rest);

  // Seg3 display sync
  const mins = document.getElementById("seg3Minutes").value;
  document.getElementById("timerDisplay").textContent = `${String(mins).padStart(2,"0")}:00`;

  // Coherence problems
  if(!coherent.ok){
    list.innerHTML = `<div class="flowStep"><span class="tag bad">mismatch</span> <span class="muted">Er zit een state-mismatch in deze flow. Druk “Nieuwe flow”.</span></div>` + list.innerHTML;
  }
}

/* --------------------- Segment 2 Rest Timer --------------------- */
let seg2Interval=null;
let seg2Running=false;
let seg2EndAt=0;

function startSeg2Rest(){
  const rest = parseInt(document.getElementById("seg2Rest").value,10);
  seg2EndAt = Date.now() + rest*1000;
  seg2Running = true;
  beep(880,120);

  clearInterval(seg2Interval);
  seg2Interval = setInterval(()=>{
    const remaining = Math.max(0, Math.ceil((seg2EndAt - Date.now())/1000));
    document.getElementById("seg2Timer").textContent = formatMMSS(remaining);
    if(remaining === 0){
      clearInterval(seg2Interval);
      seg2Running = false;
      beep(660,160); setTimeout(()=>beep(990,220), 180);
    }
  }, 250);
}

function stopSeg2Rest(){
  clearInterval(seg2Interval);
  seg2Running = false;
  const rest = parseInt(document.getElementById("seg2Rest").value,10);
  document.getElementById("seg2Timer").textContent = formatMMSS(rest);
}

/* --------------------- Segment 3 Timer --------------------- */
async function startTimer(){
  const mins = parseInt(document.getElementById("seg3Minutes").value,10);
  const total = mins * 60;
  endAt = Date.now() + total*1000;
  timerRunning = true;

  beep(880,120);
  await enableWakeLock();

  clearInterval(timerInterval);
  timerInterval = setInterval(()=>{
    const remaining = Math.max(0, Math.ceil((endAt - Date.now())/1000));
    document.getElementById("timerDisplay").textContent = formatMMSS(remaining);
    if(remaining === 0){
      clearInterval(timerInterval);
      timerRunning = false;
      disableWakeLock();
      beep(660,160); setTimeout(()=>beep(990,220), 180);
    }
  }, 250);
}

function stopTimer(){
  clearInterval(timerInterval);
  timerRunning = false;
  disableWakeLock();
  const mins = document.getElementById("seg3Minutes").value;
  document.getElementById("timerDisplay").textContent = `${String(mins).padStart(2,"0")}:00`;
}

/* --------------------- Boot restore --------------------- */
(function boot(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if(!raw){ generateFlow(); return; }
    const saved = JSON.parse(raw);
    if(saved?.vocabMode) document.getElementById("vocabMode").value = saved.vocabMode;
    if(saved?.intentMode) document.getElementById("intentMode").value = saved.intentMode;
    if(saved?.flow?.length && saved?.base){
      const coherent = checkCoherence(saved.base, saved.flow);
      document.getElementById("cohTag").textContent = coherent.ok ? "coherent" : "warning";
      document.getElementById("cohTag").className = "tag " + (coherent.ok ? "good" : "warn");
      renderAll(saved.base, saved.intent || rChoice(INTENTS), saved.flow, coherent);
    }else{
      generateFlow();
    }
  }catch(e){
    generateFlow();
  }
})();
</script>
</body>
</html>
